## 分布式锁

同一台机器间可以通过lock来加锁，不同机器只能通过分布式锁来处理。

常用实现方式：**db**、**redis**、**zookeeper**

不管怎么样，分布式的锁服务需要有以下几个特点。

- **安全性（Safety）**：在任意时刻，只有一个客户端可以获得锁（排他性）。
- **避免死锁**：客户端最终一定可以获得锁，即使锁住某个资源的客户端在释放锁之前崩溃或者网络不可达。
- **容错性**：只要锁服务集群中的大部分节点存活，客户端就可以进行加锁解锁操作。

### 数据库实现

```sql
update lock set flag = 1 where flag = 0 and resource_key = 'resource_key';
```

如果设置成功之后会返回1，1代表成功更新的条数

如果仅仅是数据的更新，可以使用乐观锁的机制。

```sql
update store set num = $num where id = $id and num = $query_num;
```

#### 应用例子

业务A有share_a，share_b，share_c，A_d，A_e，A_f六个资源。

业务B有share_a，share_b，share_c，B_d，B_e，B_f六个资源。

A和B同时执行的时候，共享资源只能先由一个业务操作之后，再给其他资源使用。

首先开启@transactional确保获取锁是在一个事务中。

- 先查询锁表是否存在共享资源
- 不存在做共享资源的插入，如果另外一个进程也在做插入操作，已经有数据那就会报错，导致事务回滚。
- 如果插入成功（插入后要校验插入的条数是否为3）flag为1。
- 如果存在就使用update语句去更新flag为0的记录。会返回执行成功的条数，我们对比是否为3来判读是否成功争取到锁，如果没有则回滚，随机时间后做重试。

处理过程中，定时刷新updatetime。如果发现updatetime超过3分钟，就判断之前获得锁的这个业务应该已经断联，需要把这个所释放掉。其他业务就可以去获得这个锁，并进行业务的操作。

| resource | owner | flag | updatetime         |
| -------- | ----- | ---- | ------------------ |
| share_a  | A     | 1    | 2020-2-23 21:36:46 |
| share_b  | A     | 1    | 2020-2-23 21:36:46 |
| share_c  | A     | 1    | 2020-2-23 21:36:46 |



### Redis分布式锁

实现Redis分布式锁的最简单的方法就是在Redis中创建一个key，这个key有一个失效时间，以保证锁最终会被自动释放掉。当客户端释放资源(解锁）的时候，会删除掉这个key。

```powershell
 SET resource_name my_random_value NX PX 30000
```

这个命令仅在不存在key的时候才能被执行成功（NX选项），并且这个key有一个30秒的自动失效时间（PX属性）。这个key的值是“my_random_value”(一个随机值），这个值在所有的客户端必须是唯一的，所有同一key的获取者（竞争者）这个值都不能一样。

value的值必须是随机数主要是为了更安全的释放锁，释放锁的时候使用脚本告诉Redis:只有key存在并且存储的值和我指定的值一样才能告诉我删除成功。可以通过以下Lua脚本实现

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

使用这种方式释放锁可以避免删除别的客户端获取成功的锁。

看下基于cloudsop提供的redis是如果工作的

### Zookeeper

http://www.imooc.com/article/284956?block_id=tuijian_wz

## 分布式应用的挑战

### 分布式应用的优点

- **可靠性** - 单个或几个系统的故障不会使整个系统出现故障。

- **可扩展性** - 可以在需要时增加性能，通过添加更多机器，在应用程序配置中进行微小的更改，而不会有停机时间。

- **透明性** - 隐藏系统的复杂性，并将其显示为单个实体/应用程序。

### 分布式应用的挑战

  - **竞争条件** - 两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成。例如，共享资源只能在任意给定时间由单个机器修改。
  - **死锁** - 两个或多个操作等待彼此无限期完成。
  - **不一致** - 数据的部分失败。

ZooKeeper框架提供了一个完整的机制来克服所有的挑战。竞争条件和死锁使用**故障安全同步方法**进行处理。另一个主要缺点是数据的不一致性，ZooKeeper使用**原子性**解析。